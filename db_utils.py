from schema_utils import get_db_schema
import psycopg2
import os
import requests
from dotenv import load_dotenv
import re

# Load env vars
load_dotenv()

DB_HOST = os.getenv("DB_HOST")
DB_PORT = os.getenv("DB_PORT")
DB_NAME = os.getenv("DB_NAME")
DB_USER = os.getenv("DB_USER")
DB_PASS = os.getenv("DB_PASS")

def get_db_connection():
    """
    Loads environment variables and establishes a database connection.
    This ensures all parts of the app use the same, correct credentials.
    """
    load_dotenv() # Load variables from the .env file
    
    conn = psycopg2.connect(
        host=os.getenv("DB_HOST"),
        port=os.getenv("DB_PORT"),
        dbname=os.getenv("DB_NAME"),
        user=os.getenv("DB_USER"),
        password=os.getenv("DB_PASS")
    )
    return conn


def patch_sql_with_company_id(sql_query: str, company_id: str):
    """
    Ensures SQL has a tenant/company filter.
    """
    if "company_id" in sql_query.lower():
        return sql_query  # Already present âœ…

    if "where" in sql_query.lower():
        # Insert after existing WHERE clause
        return re.sub(r"(?i)where", f"WHERE company_id = '{company_id}' AND", sql_query, count=1)
    else:
        # If no WHERE clause present, add one
        return re.sub(r"(?i)(group by|order by|limit|$)",
                      f" WHERE company_id = '{company_id}' \\1", sql_query, count=1).strip()


def run_simple_query_with_llm(company_id, user_query):
    """
    Generates SQL using LLM, adds company filter, executes and returns result.
    """
    schema = get_db_schema(DB_HOST, DB_NAME, DB_USER, DB_PASS)

    prompt = f"""
You are a PostgreSQL expert working with a financial database.
Given the schema below and a natural language user query, generate ONLY the SQL query.
STRICTLY do NOT add explanations.

Schema:
{schema}

User Query: {user_query}
"""

    try:
        response = requests.post("http://localhost:11434/api/generate", json={
            "model": "llama3",
            "prompt": prompt,
            "stream": False
        })
        response.raise_for_status()
    except Exception as e:
        return [{"error": f"LLM request failed: {str(e)}"}]

    sql_query = response.json().get("response", "").strip()

    if not sql_query.lower().startswith("select"):
        return [{"error": f"Invalid SQL generated by LLM: {sql_query}"}]

    # Patch SQL to include mandatory filter
    patched_sql = patch_sql_with_company_id(sql_query, company_id)

    try:
        conn = psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASS
        )
        cursor = conn.cursor()
        cursor.execute(patched_sql)
        rows = cursor.fetchall()
        colnames = [desc[0] for desc in cursor.description]
        cursor.close()
        conn.close()
        return [dict(zip(colnames, row)) for row in rows]

    except Exception as e:
        return [{"error": f"SQL execution failed: {str(e)}"}]
    
def extract_category(user_input, known_categories):
    """
    Given user input string and a list of known categories,
    returns the first category found in the input (case-insensitive matching),
    or None if no category matches.
    """
    user_input_lower = user_input.lower()
    for category in known_categories:
        if category.lower() in user_input_lower:
            return category
    return None



def fetch_spending_for_category(company_id, user_category):
    """
    Multi-step query:
    1. Find id, qbo_parent_id for the given user_category in account_categories.
    2. Use those IDs to get transactions from budget_transaction.

    Returns list of dicts of spending data or error.
    """
    try:
        conn = psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASS
        )
        cursor = conn.cursor()

        cursor.execute("""
            SELECT id, qbo_parent_id
            FROM public.account_categories
            WHERE tenant_company_id = %s
              AND qbo_category = %s;
        """, (company_id, user_category))

        row = cursor.fetchone()
        if not row:
            cursor.close()
            conn.close()
            return {"error": f"Category '{user_category}' not found for company_id {company_id}"}

        sub_category_id, category_id = row

        cursor.execute("""
            SELECT tenant_company_id, category_id, sub_category_id, mon, *
            FROM public.budget_transaction
            WHERE tenant_company_id = %s
              AND category_id = %s
              AND sub_category_id = %s
            ORDER BY id ASC;
        """, (company_id, category_id, sub_category_id))

        rows = cursor.fetchall()
        colnames = [desc[0] for desc in cursor.description]

        cursor.close()
        conn.close()

        return [dict(zip(colnames, row)) for row in rows]

    except Exception as e:
        return {"error": f"Database error: {str(e)}"}



def get_all_categories(company_id):
    conn = psycopg2.connect(
    host=DB_HOST,
    port=DB_PORT,
    dbname=DB_NAME,
    user=DB_USER,
    password=DB_PASS
    )

    cursor = conn.cursor()
    cursor.execute("""
        SELECT DISTINCT qbo_category
        FROM public.account_categories
        WHERE tenant_company_id = %s
    """, (company_id,))
    result = [row[0] for row in cursor.fetchall()]
    cursor.close()
    conn.close()
    return result

def execute_sql_query(sql_query, conn):
    """
    Executes a given SQL query using a provided connection
    and returns the formatted results.
    """
    if not sql_query or not sql_query.strip():
        return "Invalid SQL query provided."
        
    try:
        cur = conn.cursor()
        cur.execute(sql_query)
        
        if cur.description is None:
             conn.commit()
             return "Action completed successfully."

        rows = cur.fetchall()
        colnames = [desc[0] for desc in cur.description]
        
        if not rows or (len(rows) == 1 and rows[0][0] is None):
            return [] # Return an empty list for no data
            
        return [dict(zip(colnames, row)) for row in rows]

    except Exception as e:
        # It's better to let the calling function handle logging for context
        raise e # Re-raise the exception
